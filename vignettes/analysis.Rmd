---
title: "Analysis"
output: rmarkdown::html_vignette
author: 
  - |
    Shiying Xiao$^1$, Charles Watt$^1$, Jennifer C. Liddle$^2$, Jeremy L. Balsbaugh$^2$, Timothy E. Moore$^3$
  - |
    $^1$Department of Statistics, UConn \
    $^2$Proteomics and Metabolomics Facility, UConn \
    $^3$Statistical Consulting Services, UConn
date: "`r format(file.info('analysis.Rmd')$mtime, '%Y-%m-%d')`"
bibliography:
  - ../inst/REFERENCES.bib
vignette: >
  %\VignetteIndexEntry{analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", fig.align = "center")
```


## Preliminary


```{r warning=FALSE, message=FALSE, results='hide', fig.show='hide'}
## load R package
library(msDiaLogue)
## preprocessing
fileName <- "../tests/testData/Toy_Spectronaut_Data.csv"
dataSet <- preprocessing(fileName,
                         filterNaN = TRUE, filterUnique = 2,
                         replaceBlank = TRUE, saveRm = TRUE)
## transformation
dataTran <- transform(dataSet, logFold = 2)
## normalization
dataNorm <- normalize(dataTran, normalizeType = "quant")
## imputation
dataImput <- impute.min_local(dataNorm, reportImputing = FALSE,
                              reqPercentPresent = 0.51)
## filtering
dataImput <- filterNA(dataImput, saveRm = TRUE)
```


The functions in the analysis module calculate the results that can be used
in subsequent visualizations.


<div class="note">
**Note:** The following analyses compare all other conditions against
the reference condition, which is specified by the argument `ref`,
for multiple comparisons. If `ref` is not provided, it will be automatically
generated by all the combinations of two conditions, based on the level
attributes of the condition. \
For example, suppose there are three conditions in the data: "A", "B", and "C".
If you specify `ref = "A"`, then the result includes two comparisons: "B-A" and
"C-A". If `ref = NULL`, there will be three comparisons: "A-B", "A-C", and "B-C". </div>


## Student's t-test


### Example


```{r}
anlys_t <- analyze.t(dataImput, ref = "50pmol", adjust.method = "none")
```


<div class="note">
**Note:** In the Student's t-test, a warning message might appear, stating
"**Data are essentially constant**," which means that the data contain proteins
with the same value in all samples. In this case, the p-value of t-test returns
NaN. </div>


```{r echo=FALSE}
cat("$`100pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_t$`100pmol-50pmol`)
```
</div>


```{r echo=FALSE}
cat("$`200pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_t$`200pmol-50pmol`)
```
</div>


```{r echo=FALSE}
cat("$total\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_t$total)
```
</div>


### Details


The Student's t-test is used to compare the means between two conditions for
each protein, reporting both the difference in means between the conditions and
the p-value of the test.


The argument `adjust.method` is used to specify the testing correction procedure
to be applied to p-values. This adjustment is very common in DNA or RNA-Seq
analyses, where datasets are very large and where researchers are most
interested in controlling the Type I error rate when conducting multiple
comparisons.


However, for mass spectrometry-based proteomics results, the dataset sizes are
smaller than in sequencing analyses, and testing corrections can be too harsh of
a threshold to apply. Most often, applying any testing correction to proteomics
data results in there being zero significant changes. This does not mean that
nothing is meaningfully changing in your dataset. It does mean that these
corrections are usually not a useful tool for finding biologically-relevant
changes in your dataset.


Also keep in mind that reducing Type I error typically comes at the cost of
increasing Type II error, and vice versa. There is no way to eliminate all error;
each researcher must decide whether they are more comfortable with having more
false positives or more false negatives in the dataset, and choose their
analysis strategies accordingly.


UConn PMF recommends not applying testing corrections to your proteomics dataset,
but if you would like to explore the effects of doing so, several methods are
provided below:


1. "BH" or its alias "fdr": @benjamini1995controlling.

2. "BY": @benjamini2001control.

3. "bonferroni": @bonferroni1936teoria.

4. "hochberg": @hochberg1988sharper.

5. "holm": @holm1979simple.

6. "hommel": @hommel1988stagewise.


Each method offers its own balance between statistical power and error control.
The default value `"none"` indicates that no correction is applied.


## Empirical Bayes moderated t-test


### Example


```{r}
anlys_modt <- analyze.mod_t(dataImput, ref = "50pmol", adjust.method = "none")
```


<div class="note">
**Note:** In the moderated t-test, a warning message might occur stating,
"**Zero sample variances detected, have been offset away from zero.**"
This warning corresponds to examples of proteins that exhibited identical quant
values, either pre- or post-imputation, and therefore no variance is present
across conditions for those proteins. This does not impede downstream analysis;
it merely serves to alert users to its occurrence. </div>


<!-- This just means that for at least one protein the log ratio is identical for all samples. -->
<!-- Since this will give a zero variance (which will end up in the denominator of your -->
<!-- statistic and could possibly result in an infinite value for your test statistic) it has -->
<!-- been offset to a small value to prevent that possibility. -->


```{r echo=FALSE}
cat("$`100pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_modt$`100pmol-50pmol`)
```
</div>


```{r echo=FALSE}
cat("$`200pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_modt$`200pmol-50pmol`)
```
</div>


```{r echo=FALSE}
cat("$total\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_modt$total)
```
</div>


### Details


The main distinction between the Student's and empirical Bayes moderated t-tests
[@smyth2004linear] lies in how variance is computed. While the Student's t-test
calculates variance based on the data available for each protein individually
(which will be limited by the number of replicates included for each condition),
the moderated t-test utilizes information from all replicates of every protein
in the current dataset to calculate variance.


## Wilcoxon test


### Example


```{r warning=FALSE}
anlys_wilcox <- analyze.wilcox(dataImput, ref = "50pmol", adjust.method = "none")
```


<div class="note">
**Note:** In the Wilcoxon test, the warning message
"**cannot compute exact p-value with ties.**" may be displayed.
This warning means that some values with tied rankings and the sample size is
lower than 50, which prevents the exact p-value from being calculated. In such
cases, a normal approximation is used. If all samples for a protein have the
same value, the corresponding p-value returns NaN. </div>


```{r echo=FALSE}
cat("$`100pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_wilcox$`100pmol-50pmol`)
```
</div>


```{r echo=FALSE}
cat("$`200pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_wilcox$`200pmol-50pmol`)
```
</div>


```{r echo=FALSE}
cat("$total\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_wilcox$total)
```
</div>


### Details


The Wilcoxon test is a non-parametric alternative to the two-sample t-test.
If `paired = TRUE`, a Wilcoxon signed-rank test is performed to test the null
hypothesis that the distribution of the difference between the two conditions
for the protein is symmetric about zero. If `paired = FALSE`, a Wilcoxon
rank-sum test (also known as Mann-Whitney test) is performed to test the null
hypothesis that the distribution of the two conditions for the protein are
the same.


## MA


### Example


```{r}
anlys_ma <- analyze.ma(dataImput, ref = "50pmol")
```


```{r echo=FALSE}
cat("$`100pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_ma$`100pmol-50pmol`)
```
</div>


```{r echo=FALSE}
cat("$`200pmol-50pmol`\n")
```
<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_ma$`200pmol-50pmol`)
```
</div>


### Details


The result of `method = "MA"` is to generate the data for an MA plot, which
plots the average fold change between two conditions (y-axis) against the
average abundance of that protein (x-axis). This is helpful for evaluating
whether a fold-change difference is being enhanced by low overall intensities
(e.g. a change from 200 to 400 is the same fold-change as from 20,000 to 40,000,
but the latter is a more robust measurement and less susceptible to noise
interference).


## PCA


### Example


In the case of `dataImput`, one protein, namely "ALBU_BOVIN", has constant
values, leading to the error message. We choose to remove this protein in the
principal component analysis (PCA).


```{r}
names(dataImput)[sapply(dataImput, function(col) length(unique(col)) == 1)]
dataPCA <- dataImput[, colnames(dataImput) != "ALBU_BOVIN"]
anlys_pca <- analyze.pca(dataPCA, center = TRUE, scale = TRUE)
```


<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_pca$loadings)
```
</div>


### Details


PCA is a powerful technique used in data analysis to simplify and reduce the
dimensionality of large datasets. It transforms original variables into
uncorrelated components that capture the maximum variance. By selecting a subset
of these components, PCA projects the data points onto these key directions,
enabling visualization and analysis in a lower-dimensional space. This aids in
identifying patterns and relationships within complex datasets.


For PCA, the arguments `center` and `scale` are used to center the data to zero
mean and scale to unit variance, with default setting at `TRUE`.


<div class="note">
**Note:** Data scaling is done to ensure that the scale differences between
different features do not affect the results of PCA. If not scaled, features
with larger scales will dominate the computation of principal components (PCs). \
**Note:** The most common error message for the PCA is
"**Cannot rescale a constant/zero column to unit variance**."
This clearly occurs when columns representing proteins contain only zeros or
have constant values. Typically, there are two ways to address this error: one
is to remove these proteins, and the other is to set `scale = FALSE`. </div>


## PLS-DA


### Example


```{r}
anlys_plsda <- analyze.plsda(dataImput, method = "kernelpls",
                             center = TRUE, scale = FALSE)
```


<div style="overflow-x: auto;">
```{r echo=FALSE}
knitr::kable(anlys_plsda$loadings)
```
</div>


### Details


Partial least squares-discriminant analysis (PLS-DA) adapts PLS regression for
supervised classification. Rather than simply finding directions of maximal
variances in the predictors as PCA does, PLS-DA extracts latent components that
maximize the covariance between predictors and dummy-coded group labels. This
ensures that the resulting components optimally separate predefined groups and
yields variable-importance scores directly tied to classification.


For PLS-DA, the argument `method` specifies which multivariate regression
algorithm to use:


1. "kernelpls": Kernel algorithm [@dayal1997improved].

2. "widekernelpls": Wide kernel algorithm [@rannar1994pls].

3. "simpls": SIMPLS  algorithm [@dejong1993simpls].

4. "oscorespls": NIPALS algorithm (classical orthogonal scores algorithm)
[@martens1989multivariate].


The argument `ncomp` sets the number of components to include in the model. It
defaults to min(n-1, p). The arguments `center` and `scale` control whether the
data are centered to zero mean and scaled to unit variance, respectively.


## Reference {-}


<div class="nav-button left-button">
<a href="summarization.html">← Previous</a>
</div>
<div class="nav-button right-button">
<a href="visualization.html">Next →</a>
</div>

